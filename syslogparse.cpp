// Apparmor / IPTables Rule Parser
// Colin O'Brien - insanitybit
// $make all
// source available at: https://github.com/insanitybit/SyslogParser
/*
The goal of this program is to parse the system log for two things:
1) Apparmor denials
2) Iptables logs

The current tools for both of these actions are lacking in terms of both performance and usability.
*/

#include <chrono>
// seccomp / rlimit / caps / namespace / rand UID
#include <sys/prctl.h>
#include <seccomp.h>
#include <sys/resource.h>
#include <linux/capability.h>
#include <cap-ng.h>
#include <sched.h>
#include <grp.h>
#include <pwd.h> 
#include <time.h>
#include <fstream>
// necessary
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <iostream>
#include <string>
#include <vector>
#include <array>
#include <map>
#include <thread>
#include <atomic>
#include <mutex>
#include <linux/futex.h>
#include <algorithm>
#include <functional>
#include <err.h>
#include <sys/mman.h>

#include "Threadpool.h"
using namespace std;

/*
chunk() takes in the mmap'd file buffer, CPU count, and size of the buffer. It splits it into 
CPUcount chunks and returns a vector 'chunks'.
*/

vector <string> chunk(const string &buff, const uint32_t core_count, const size_t length);

/*
Parser fn's will take in a string from the vector of strings returned from chunks. They parse this 
and pull out a vector of string vectors, each one holding the relevant information for a rule
*/

void aaparse(const string &str, vector<vector<string> >& parsedvals);
void ipparse(const string &str, vector<vector<string> >& parsedvals);

/*
Generators take in a vector of string vectors generated by parse fn's. They look at each string
within a vector and generate the logical rule for that vector.
*/

void aagen(const vector<string>& pvals, vector<string>& rules);
void ipgen(const vector<string>& pvals, vector<string>& rules);

/*
Sandbox is documented here: http://www.insanitybit.com/2014/09/09/writing-sandboxed-software-2/

ToDo: Set nproc limit on UID before dropping.
*/

void sandbox();

mutex mtx;

typedef function<void(const string &str, vector<vector<string> >& parsedvals)> pfnc;
typedef function<void(const vector<string>&, vector<string>&)> gfnc;

int main(int argc, char *argv[]){
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<double> elapsed_seconds;

	if(getuid())
		err(0, "Must be run as root user");

	if(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1)
	 	err(0, "PR_SET_NO_NEW_PRIVS failed");

	if(prctl(PR_SET_DUMPABLE, 0) == -1)
		err(0, "PR_SET_DUMPABLE failed");

	capng_clear(CAPNG_SELECT_BOTH);
	capng_updatev(CAPNG_ADD, (capng_type_t)(CAPNG_EFFECTIVE | CAPNG_PERMITTED),CAP_SYS_ADMIN, CAP_SETUID, CAP_SETGID, CAP_SYS_CHROOT, CAP_DAC_READ_SEARCH, -1);
	capng_apply(CAPNG_SELECT_BOTH);

	uint32_t MAX_CPU;
	size_t i;
	string logbuff;
	vector<string> threadbuffs;
	
	function<void(const string &str, vector<vector<string> >& parsedvals)> parse;
	function<void(const vector<string>& pvals, vector<string>& rules)> gen;

	if(argc <= 1){
		// cout << "SyslogParse takes two arguments:\n'iptables' or 'apparmor' (required) \n path to logfile (optional)\n";
		exit(1);
	}

	const string dec = argv[1];
	const char * logfile = argv[2];

   	if(dec == "apparmor"){
   		parse = &aaparse;
		gen = &aagen;
	}else if(dec == "iptables"){
		parse = &ipparse;
		gen = &ipgen;
	}else{
		err(0, "Invalid argument");
	}

	if(logfile == NULL){ // remember apparmor profile, argv[2] must be readable
		logfile = "/var/log/syslog";
	}else{
		// validate that logfile is in /var/log - sandboxing will prevent reading from anywhere else!
		string lf = logfile;
		if(lf.substr(0,9) != "/var/log/")
			err(0, "can only read files in /var/log/");
	}

	// set MAX_CPU
	ifstream file("/proc/sys/kernel/threads-max");

	if(file){
		string tmp;
		getline(file, tmp);
		MAX_CPU = atoi(tmp.c_str());
		file.close();
	}else{
		MAX_CPU = 512;
	}

	// Check for CPU core count
	size_t core_count;// = sysconf( _SC_NPROCESSORS_ONLN );
	core_count = thread::hardware_concurrency();
	if ((core_count < 1) || (core_count > MAX_CPU))
			core_count = 2; // If we get some weird response, assume that the system is at least a dual core.

	start = std::chrono::steady_clock::now();
	end = std::chrono::steady_clock::now();

	ifstream logf(logfile);

	if(!logf)
		err(0, "log open failed");
	
	const size_t logsize = logf.tellg();

	logf.seekg(0, ios::end);   
	logbuff.reserve(logsize);
	logf.seekg(0, ios::beg);

	logbuff.assign((istreambuf_iterator<char>(logf)),
	            istreambuf_iterator<char>());

	logf.close();

	elapsed_seconds = end-start;
	// cout << "openlog::  " << elapsed_seconds.count() << "ms" << endl;

	start = std::chrono::steady_clock::now();
	end = std::chrono::steady_clock::now();
	
	//sandbox();

	elapsed_seconds = end-start;
	// cout << "sandbox::  " << elapsed_seconds.count() << "ms" << endl;
	
	start = std::chrono::steady_clock::now();
	end = std::chrono::steady_clock::now();

	threadbuffs.reserve(core_count);
	threadbuffs = chunk(logbuff, core_count, logsize);
	
	elapsed_seconds = end-start;
	// cout << "chunk::  " << elapsed_seconds.count() * 1000 << "ms" << endl;
	
	vector<thread> threads(core_count);	
	vector<vector<string>> parsedvals;

	start = std::chrono::steady_clock::now();

	// Threadpool<pfnc, vector<string>, vector<vector<string> > > pool(core_count);
	// pool.set_function(parse);
	// pool.set_input(ref(threadbuffs));
	// pool.set_output(ref(parsedvals));
	// pool.execute_no_atomic();
	// pool.join();

	i = 0;
	for (vector<string>::const_iterator it = threadbuffs.begin() ; it != threadbuffs.end(); ++it){
		threads.at(i) = (thread(parse, std::cref(*it), std::ref(parsedvals)));
		i++;
	}

	for_each(threads.begin(), threads.end(), mem_fn(&std::thread::join));

	end = std::chrono::steady_clock::now();

	elapsed_seconds = end-start;
	cout << "parse::  " << elapsed_seconds.count() * 1000 << "ms" << endl;


	if(parsedvals.size() < 1)
		err(0, "parsedvals.size() < 1");

	sort(parsedvals.begin(), parsedvals.end());
	vector<vector<string> >::iterator it;
	it = unique (parsedvals.begin(), parsedvals.end()); 
  	parsedvals.resize( distance(parsedvals.begin(),it) );
	//// cout << parsedvals.size() << endl;

	// Begin rule generation
  	vector<string> rules;

  //rules.resize(parsedvals.size()); //Remove mutex, instead use atomic increment - should speed up a lot
	threads.clear();

	// Threadpool!
	//cout <<  << endl;
	

	start = std::chrono::steady_clock::now();

	Threadpool<gfnc, vector<vector<string> >, vector<string> > gpool(core_count);
	gpool.set_function(gen);
	gpool.set_input(ref(parsedvals));
	gpool.set_output(ref(rules));
	gpool.execute_no_atomic();
	gpool.join();

	rules = gpool.get_output();

	// for (vector<vector<string> >::const_iterator it = parsedvals.begin() ; it != parsedvals.end(); ++it){
	// 	// create threads core_count at a time
	// 	for(i = 0; i < core_count; i++){
	// 		threads.push_back(thread(gen, std::cref(*it), std::ref(rules)));
	// 		if(it != parsedvals.end() - 1)	// Last one? Iterate, push, and break
	// 			++it;
	// 		else
	// 			break;
	// 	}
	// 	for_each(threads.begin(), threads.end(), mem_fn(&std::thread::join));
	// 	threads.clear();
	// }
	// 	// If we break we have to clean up
	// 	for_each(threads.begin(), threads.end(), mem_fn(&std::thread::join));
	// 		threads.clear();

	end = std::chrono::steady_clock::now();

	elapsed_seconds = end-start;
	cout << "gen::  " << elapsed_seconds.count() * 1000 << "ms" << endl;

	// // cout rules

	for(vector<string>::const_iterator it = rules.begin() ; it != rules.end(); ++it)
		cout << *it << endl;

	return 0;
}

void ipgen(const vector<string>& pvals, vector<string>& rules){
	// [direction][device][mac][srcip][dstip][protocol][srcport][destport]
	// iptables -A OUTPUT -p tcp -m multiport --dports 80,8080,8000,443 -j ACCEPT

	const string iptables 			= "iptables -A ";
	const string input 				= "INPUT ";
	const string output				= "OUTPUT ";
	const string in_device			= "-i ";
	const string out_device			= "-o ";
	const string source 			= " -s ";
	const string destination 		= " -d ";
	const string protocol			= " -p ";
	const string source_port		= " --sport ";
	const string destination_port	= " --dport ";

	string rule = "";
	
	if(pvals[0] == "INPUT"){							
				rule  = iptables 	+ 		input 
				+		in_device 	+ 		pvals[1] 
				+		source 		+ 		pvals[4] 
				+		destination + 		pvals[5] 
				+		protocol 	+ 		pvals[6] 
				+		destination_port +	pvals[7];
	}else if(pvals[0] == "OUTPUT"){
				rule  = iptables 	+ 	output
				+		out_device 	+ 	pvals[1]
				+		source 		+ 	pvals[4]
				+		destination + 	pvals[5]
				+		protocol	+	pvals[6]
				+		source_port +	pvals[7];
	}else{
		return;
		err(0, "pvals[0] is not INPUT or OUTPUT.");
	}
	//rules.at(i) = rule;
	mtx.lock();
//	cout << i << endl;
//	cout << rules.size() << endl;
//	cout << rule << endl;
	rules.push_back(rule);
	mtx.unlock();
}

void aagen(const vector<string>& pvals, vector<string>& rules){
// Information Type A:[operation] [profile] [name] [denied_mask]
// Information Type B:[operation] [profile] [capname]

// Steps involved:
// Take in vector of strings containing either Information Type A or B
// Transform that information into a rule
// Reduce rules
// Expand rules
// Validate rules REGEX
// Rate 'danger' of rule
// Throw out rules

//0 - 10, 10 being greatest. -1 is unknown danger.

// int8_t danger = -1;

// map<string,int8_t> caps; //arbitrary right now for testing
// 						caps["chown"] = 5;
// 						caps["dac_override"] = 10;
// 						caps["dac_read_search"] = 7;
// 						caps["fowner"] = 5;
// 						caps["fsetid"] = 10;
// 						caps["kill"] = 3;
// 						caps["setgid"] = 10;
// 						caps["setuid"] = 10;
// 						caps["setpcap"] = 5;
// 						caps["linux_immutable"] = 1;
// 						caps["net_bind_service"] = 2;
// 						caps["net_broadcast"] = 2;
// 						caps["net_admin"] = 2;
// 						caps["net_raw"] = 2;
// 						caps["ipc_lock"] = 0;
// 						caps["ipc_owner"] = 5;
// 						caps["sys_module"] = 1;
// 						caps["sys_rawio"] = 1;
// 						caps["sys_chroot"] = 1;
// 						caps["sys_ptrace"] = 7;
// 						caps["sys_pacct"] = -1;
// 						caps["sys_admin"] = 10;
// 						caps["sys_boot"] = -1;
// 						caps["sys_nice"] = 0;
// 						caps["sys_resource"] = 0;
// 						caps["sys_time"] = 7;
// 						caps["sys_tty_config"] = -1;
// 						caps["mknod"] = -1;
// 						caps["lease"] = -1;
// 						caps["audit_write"] = 5;
// 						caps["audit_control"] = 5;
// 						caps["setfcap"] = 5;
// 						caps["mac_override"] = 10; 	// never allow
// 						caps["mac_admin"] = 10;		// never allow

	string operation 	= pvals[0];
	string profile		= pvals[1];

	// for(int i = 0; i < pvals.size(); ++i){
	// 	mtx.lock();
	// 	// cout << pvals[i] << endl;
	// 	mtx.unlock();
	// }

	if(operation == "capable"){
	//	danger += caps[pvals[2]];
		string capname = pvals[2];
		string rule = "profile:: " + profile + " rule:: capability " + capname + ",\n";
		// validate capname first
		mtx.lock();
		rules.push_back(rule);
		mtx.unlock();
		return;
	}

	string name = pvals[2];
	string denied_mask = pvals[3];

	size_t cpos;
	if((cpos = profile.find("///")) == string::npos){ // no child found
		string rule = "profile:: " + profile + " child:: NULL rule:: " + name + " " + denied_mask + ",\n";
		mtx.lock();
		rules.push_back(rule);
		mtx.unlock();
		return;
	}
	// get the child path
	string child = profile.substr((cpos + 2), profile.length()); 	// use magic 2 to get past the /s
	profile = profile.substr(0, cpos);
	string rule = "profile:: " + profile + " child:: " + child + " rule:: " + name + " " + denied_mask + ",\n";
	mtx.lock();
	rules.push_back(rule);
	mtx.unlock();
	return;
}

void ipparse(const string &str, vector<vector<string> >& parsedvals){
// IPTABLESINPUT: IN=lo OUT= MAC=00:**:** SRC=127.0.0.1 DST=127.0.0.1 
// LEN=240 TOS=0x00 PREC=0x00 TTL=64 ID=10566 DF PROTO=UDP SPT=42102 DPT=123 LEN=220 

// [direction][device][mac][srcip][dstip][protocol][srcport][destport]

	const string iptables 			= "IPTABLES";
	const string input 				= "INPUT";
	const string output				= "OUTPUT";
	const string in_device			= "IN=";
	const string out_device			= "OUT=";
	const string macaddr			= "MAC=";
	const string source 			= "SRC=";
	const string destination 		= "DST=";
	const string protocol			= "PROTO=";
	const string source_port		= "SPT=";
	const string destination_port	= "DPT=";

	const array <string, 8> atts = {
									in_device,
									out_device,
									macaddr,
									source,
									destination,
									protocol,
									source_port,
									destination_port
									};
	size_t i;
	size_t aapos;
	size_t laapos = 0;
	size_t pos1;
	size_t pos2;
	string pstr;

	vector<string> attributes;

	aapos = str.find(iptables, laapos);
	if(aapos == string::npos)
		return;

	while(true){
		// find apparmor violation
		aapos = str.find(iptables, laapos); // point to beginning of IPTABLES
		if(aapos == string::npos)
			return;

		aapos += iptables.length();			// point to end of IPTABLEs
		laapos = aapos;
		
		// is this input or output
		pos1 = str.find(iptables, aapos); 	// point to beginning of INPUT: or OUTPUT:
		if(pos1 == string::npos)
			break;
		pos1 += iptables.length();			// point to end of INPUT or OUTPUT:
		pos2 = str.find(":", pos1);
		if(pos2 == string::npos)
			break;
		pos2 -= pos1;
		pstr = str.substr(pos1, pos2);
		attributes.push_back(pstr);
		if(pstr != input && pstr != output)
			break;


		// This could be faster, can split into two loops instead
		for(i = 0; i < atts.size(); i++){
			pos1 = str.find(atts.at(i), aapos);
			if(pos1 == string::npos)
				return;
			
			// if(i == 6){ //
			// 	attributes.push_back("SPT");
			// 	continue;
			// }
			// else if(i == 7){ // attributes[0] == "OUTPUT"  && 
			// 	attributes.push_back("DPT");
			// 	continue;
			// }
			if(i == 2){
				attributes.push_back("MAC"); 	// MAC is annoying and unimportant for security.
				continue;						// Plus, removing makes unique() far more effective
			}
			pos1 += atts.at(i).length();
			pos2 = str.find(" ", pos1);
			if(pos2 == string::npos)
				return;
			pos2 = pos2 - pos1;
			pstr = str.substr(pos1, pos2);
			attributes.push_back(pstr);

		}
		mtx.lock();
		parsedvals.push_back(attributes);
		mtx.unlock();
		attributes.clear();
	}
}


void aaparse(const string &str, vector<vector<string> >& parsedvals){

// Parse out individual pieces of information that are relevant:
// Information Type A:[operation] [profile] [name] [denied_mask]
// Information Type B:[operation] [profile] [capname]

	const string apparmor 		= "apparmor=\"";
	const string operation		= "operation=\"";
	const string profile 		= "profile=\"";		// the profile path for the program
	const string denied_mask	= "denied_mask=\"";	// how the program tried ot access the file
	const string name 			= "name=\"";		// the file the program tried to access	
	const string capname		= "capname=\"";
	const string status 		= "STATUS";

	const array<string, 3> atts 	= {profile, name, denied_mask};
	const array<string, 2> catts 	= {profile, capname};
	vector<string> attributes;

	size_t i;
	size_t aapos;		// position of apparmor statement beginning
	size_t laapos = 0;	// position of the previous apparmor statement beginning
	size_t pos1;		// beginning of string we want to snip
	size_t pos2;		// end of string we want to snip
	string pstr;

	aapos = str.find(apparmor, laapos);
	if(aapos == string::npos)
		return;

	while(true){
		// find apparmor violation
		aapos = str.find(apparmor, laapos);
		if(aapos == string::npos)
			return;

		aapos += apparmor.length();
		laapos = aapos;

		// handle apparmor="STATUS"
		// if we end up needing "ALLOWED" or "DENIED" just do it here
		pos1 = aapos;
		pos2 = str.find("\"", pos1);
		if(pos2 == string::npos)
			return; // I should maybe turn these into continues
		pos2 -= pos1;
		pstr = str.substr(pos1, pos2);
		if(pstr == status)
			continue;
		// is this a capability or not?
		pos1 = str.find(operation, aapos);
		if(pos1 == string::npos)
			return;
		pos1 += operation.length();
		pos2 = str.find("\"", pos1);
		if(pos2 == string::npos)
			return;
		pos2 -= pos1;
		pstr = str.substr(pos1, pos2);
		attributes.push_back(pstr);

		// if it is a capability
		if(pstr == "capable"){
			for(i = 0; i < catts.size(); i++){
				pos1 = str.find(catts.at(i), aapos);
				if(pos1 == string::npos)
				return;

				pos1 += catts.at(i).length();
				pos2 = str.find("\"", pos1);
				if(pos2 == string::npos)
					return;
				pos2 = pos2 - pos1;
				pstr = str.substr(pos1, pos2);
				attributes.push_back(pstr);
			}
		}
		// if it is not a capability
		// extract the 3 attributes we want from it. profile, denied mask, name
		else{
			for(i = 0; i < atts.size(); i++){
				pos1 = str.find(atts.at(i), aapos);
				if(pos1 == string::npos)
					return;

				pos1 += atts.at(i).length();
				pos2 = str.find("\"", pos1);
				if(pos2 == string::npos)
					return;
				pos2 = pos2 - pos1;
				pstr = str.substr(pos1, pos2);				
				attributes.push_back(pstr);
			}
		mtx.lock();
		parsedvals.push_back(attributes);
		mtx.unlock();
		attributes.clear();
		}
	}
}

vector<string> chunk(const string &buff, const uint32_t core_count, const size_t length){
	size_t i;
	uint8_t j;
	size_t lp = 1;
	vector<string> chunks(core_count, "");
	string rbuff;

	for(j = 1; j <= core_count; j++) {
		i = (static_cast<float>(length) * (static_cast<float>(j) / static_cast<float>(core_count)));
 		i = buff.find('\n', i);
 		if(i == string::npos){			// If we search for \n but don't find it
 			i = (length - 1);
			rbuff = buff.substr(lp, (i - lp));
			chunks.push_back(rbuff);
			return chunks;
 		}
		rbuff = buff.substr(lp, (i - lp));
		lp = i + 1; 					// lp is equal to the character AFTER the new line
		chunks[j - 1] = rbuff;
 	}
return chunks;
}

void sandbox(){

	uint64_t seed;
	ifstream rfile("/dev/urandom");
	
	rfile.read(reinterpret_cast<char*>(&seed), sizeof(seed));

	rfile.close();
	//// cout << seed << endl;

	/*
	std::random_device rd;     // only used once to initialise engine
	std::mt19937 rng(rd);      // random-number engine used
	std::uniform_int_distribution<int> uni(min,max); // guaranteed unbiased

	auto random_integer = uni(rng);
	*/
	srand(seed);

	passwd 	*ps;
	group 	*gr;

	uid_t uid = (rand()%4294967296) + 1;
	gid_t gid = (rand()%4294967296) + 1;

	while((ps = getpwuid(uid)) != NULL)
	 	uid = (rand()%4294967296) + 1;

	while((gr = getgrgid(gid)) != NULL)
		gid = (rand()%4294967296) + 1;
	
	// Namespaces
	if(unshare((CLONE_NEWIPC | CLONE_NEWNS | CLONE_FILES)))
		err(0, "unshare failed");

	// set up chroot

	mkdir("/tmp/syslogparse/", 400);

	if(chdir("/tmp/syslogparse/"))
		err(0, "chdir failed");
	
	if(chroot("/tmp/syslogparse/"))
		err(0, "chroot failed");

	// Prevent all file writes... again. 
	struct rlimit rlp;
	rlp.rlim_cur = 0;

	if(setrlimit(RLIMIT_FSIZE, &rlp))
		err(0, "rlimit failed");

	if (setgid(gid))
		err(0, "setgid failed.");
    if (setuid(uid))
        err(0, "setuid failed.");

    // // cout << "GID = " << getgid() << endl;

    // // cout << "UID = " << getuid() << endl;

    // seccomp

	scmp_filter_ctx ctx;
	ctx = seccomp_init(SCMP_ACT_KILL);

	// rules - In Progress: Find rules where filtering parameters is viable

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(tgkill), 0);

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(access), 0);
//	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0);

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 1,
										  SCMP_A0(SCMP_CMP_GE, 1),
										  SCMP_A0(SCMP_CMP_LE, 2)
										  );

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(fstat), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(close), 0);

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(brk), 0);

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(mprotect),  1,
										  SCMP_A2(SCMP_CMP_NE, PROT_EXEC)
										  );

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(mmap),  2,
										  SCMP_A0(SCMP_CMP_EQ, 0),
										  SCMP_A5(SCMP_CMP_EQ, 0)
										  );

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(munmap), 2,
										  SCMP_A0(SCMP_CMP_NE, 0),
										  SCMP_A1(SCMP_CMP_GE, 0)
										  );
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(madvise), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(futex), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(execve), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(clone), 0);

	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(getrlimit), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigaction), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigprocmask), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(set_robust_list), 0);
	seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(set_tid_address), 0);

	if(seccomp_load(ctx))			//activate filter
		err(0, "seccomp_load failed"); 

  	// sandbox complete

}